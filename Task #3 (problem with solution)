/*

Using the language JavaScript— to write a console script that implements a generalized non-transitive dice game (with the supports of arbitrary values on the dice).
When launched with command line parameters—arguments to the main or Main method in the case of Java or C# correspondingly, sys.argv in Python, process.argv in Node.js, etc.—it accepts 3 or more strings, each containing 6 comma-separated integers. E.g., python game.py 2,2,4,4,9,9 6,8,1,1,8,6 7,5,3,7,5,3. In principle, you may support any number of faces on a dice, like 4 or 20, but it's not very important.

If the arguments are incorrect, you must display a neat error message,not a stacktrace—what exactly is wrong and an example of how to do it right (e.g., user specified only two dice or no dice at all, used non-integers, etc.). All messages should be in English.

Important: dice configuration is passed as command line arguments; you don't "parse" it from the input stream. The victory is defined as follows—computer and user select different dice, perform their "rolls," and whoever rolls higher wins. The first step of the game is to determine who makes the first move. You have to prove to the user that choice is fair (it's not enough to generate a random bit 0 or 1; the user needs a proof of the fair play). When the users make the roll, they select dice using CLI "menu" and "generate" a random value with the help of the computer. The options consist of all the available dice, the exit (cancel) option, and the help option. When the computer makes the roll, it selects dice and "generates" a random value. 
Of course, "random" generation is also should be provable fair.

Please, note that the task is not "to implement some dice game". You need to implement all the specified requirements, including fair random generation, configurable dice, classes with limited responsibilities, etc. If fact, it's not a "dice game" at all, but rather a mathematical model of intransitive relations. You can think of the "higher" face result as "better" or "nicer" or any other relation. As far as I know, there is no such games in reality. So, you need to implement provable "fair" random integer generation (other from 0 to 1 or from 0 to 5).

To generate such a value, the computer generates a one-time cryptographically secure random key (using corresponding API like SecureRandom, RandomNumberGenerator, random_bytes, etc.—it's mandatory) with a length of at least 256 bits. Then the computer generates a uniformly distributed integer in the required range (using secure random; note that % operator is not enough to get uniform distribution) and calculates HMAC (based on SHA3) from the generated integers as a message with the generated secret key. Then the computer displays the HMAC to the user. After that, the user selects an integer in the same range. The resulted value is calculated as the sum of user number and computer number using modular arithmetic. When the computer displays the result, it also shows the used secret keys.
The sequence is critical (it simply doesn't make sense to do it differently, for example, showing the key before the user number selection or displaying HMAC the second time instead of the key, etc.).

Note that each "fair random generation" requires the participation of both parties, the user and the computer; just to generate random number and print it is not enough. Thus the user can check that the computer doesn't cheat (of course, the computer can still try to cheat, but the user can counteract to that). When you select the "help" option in the terminal, you need to display a table (use ASCII-graphic) that shows probabilities of winning for each dice pair.

The table generation should be in a separate class. The probability calculation should be in a separate class. The implementation of the fair number generation "protocol" should be in a separate class. The random key/number generation and HMAC calculation should be in a separate class. The dice configuration parsing should be in a separate class. The dice abstraction should be in a separate class. Generally, your code should consist of at least 6-9 classes. You should use the core class libraries and third-party libraries to the maximum, and not reinvent the wheel. 

THE NUMBER OF DICE CAN BE ARBITRARY ( > 2).

The first "fair generation" (0 or 1) should determine who selects the dice first. The opponents select different dice and after that dice rolls are performed (in fact, the order of rolls should be unimportant, because they use different dice). Of course, both computer's and user's rolls should be "fair" (use "input" from both parties).

And as an explanation: when calculating HMAC, the key is the same secret key that you generated. And the message is a number. After getting the key, the user will be able to calculate the HMAC and compare it with the HMAC that was shown before. It's not very difficult. Each "fair random" depends on numbers, generated by both players (human and computer). HMAC is used to prove that computer did't change its number after user made the selection. A common mistake is trying to invent your "HMAC" as a hash of a random "key." This will not work. If you show the same lines before the user selection and after the user selection, the user does not receive new information, and, accordingly, you do not prove anything to him. It is necessary to generate a key (with a secure generator), generate a computer value, calculate HMAC (by a standard algorithm) from a computer value (message) and a key (key), show HMAC, get a user value, calculate the result and show the key. Re-read this paragraph until the total comprehension.

*/
