Here is some libraries you may use for your implementation of help tables: ascii-table (npm package) or ConsoleTable (Nuget package) or terminal-table (Ruby gem) или Console_Table (PHP). Obviously, you may use any other. And here is the explanation what hash and HMAC is: ⁠iLearning⁠

Small note: in the case of the sum of two bits (modulo 2), it can be considered as whether user and computer choices are equal or not (if user guessed the computer choice 0 or 1, user selects the dice first).

How to calculate the win probability?
Let's say we have two dice, a and b, as int arrays. We can count the number of times when an element in the first array is greater than an element in the second. If we divide the result by the product of array lengths, we get the probability.

The simplest possible variant is to write something like the following (let's use C# for this example):
public int CountWins(int[] a, int[] b) {
    int n = 0;
    foreach(var x in a) {
        foreach(var y in b) {
            if (x > y) n++;
        }
    }
    return n;
}

Note that code doesn't depend on the face count (we can use 6 or 20 or 100).

There are quite a few reasons why for-loops are usually not the best option, so you may (well, rather have to) rewrite that using the "somebody already did it" approach:
public int CountWins(int[] a, int[] b) {
    return a.SelectMany(_ => b, (x, y) => x > y).Count(x => x);
}

Note that we still support arbitrary face count and code is much more concise.

You may think that it's not very efficient to loop over all possible pairs, because the time complexity of the algorithm is quadratic in relation to the face count. But it's simple; in my opinion, in this case it's better to stop here. And it's easier to transform this version into "parallel" one than the first.

The standard heuristic is to sort data (the values on the faces in our case). The sort operation requires Θ(n log n) time complexity, and after that we can reuse the standard API to write a piece of code, which is a little more cryptic, but theoretically faster for a dice with a very large face count:
public int CountWins(int[] a, int[] b) {
    return a.Select(x => ~Array.BinarySearch(b, x, 
        Comparer<int>.Create((x, y) => Math.Sign(x - y + 0.5)))).Sum();
}

But again, it's a very speculative "what if I was asked" situation; it should't be considered as a recommended way to do things (the second variant is).

A note: DON'T REUSE SECRET KEY. You have to generate a new key before every HMAC calculationn for every fair collaborative random integer generation. After you showed the key to the users, they can calculate the computer choice from the next HMAC value before they make their selection.
Yes, it's possible and really trivial:

const crypto = require("node:crypto");
console.log(crypto.createHash("sha3-256").update("abc").digest("hex"));

or

<?php
  echo hash("sha3-256", "abc"), PHP_EOL;
?>

or

using var sha3 = System.Security.Cryptography.SHA3_256.Create();
var hash = sha3.ComputeHash(System.Text.Encoding.UTF8.GetBytes("abc"));
System.Console.WriteLine(System.Convert.ToHexStringLower(hash));

In this task you don't need async calls at all because, you don't want to sort array before you read files, right? Just use readFileSync instead of readFile. Get user input from terminal (related to the task #3)

So, you have some basic setup:
const readline = require("readline").createInterface({
    input: process.stdin,
    output: process.stdout
});

And you try to write something like this
console.log("Start");
const value = readline.question("Your value:", function(move) {
    console.log("Your value is " + value);
    readline.close();
});
console.log("Finish");

And expectedly you get the following output
Start
Your value:Finish
rock
Your value is rock

But you want to get something different, right?
There are many ways to get the needed result. E.g., you may use promises. You need to put your code inside the function — obviously, "global" code outside functions/obejcts/modules/etc. is a really bad idea anyway. So, you can write
async function question(hind) {
    return new Promise(r => {
        readline.question("Your value:", r); 
    });
}

async function main() {
    console.log("Start");
    const value = await question("Your value:");
    console.log("Your value is " + value);
    console.log("Finish");
    readline.close();
}

main();

And get
Start
Your value:rock
Your value is rock
Finish

Also — it's arguably better approach — apply the "don't reinvent the wheel" rule and use readline-sync (use the mantra "we are not the first people to encounter this")
const readline = require("readline-sync"); 

console.log("Start");
const value = readline.question("Your value:");
console.log("Your value is " + value);
console.log("Finish");

It's simpler and cleaner, because, well, you don't need anything asynchronous there.

When the dice 2/2/4/4/9/9 is played against itself, the probability of winning is 0.3333, because there are only 12 winning combinations over 36 possible: the first 4 over the first 2, the first 4 over the second 2, the second 4 over the  first 2, the second 4 over the second 2, the first 9 over 2 or 2 or 4 or 4, and the second 9 over 2 or 2 or 4 or 4.

It's  better to design your code for extension, not modification it. But some choose the approach with the error type enums and some kind of static switch-based method creating instances of Error by the enum value or something. Sometimes "Error" has additional logic, adding an usage example to all messages, and that's a good idea. But enums ain't very cool... They are closed for extension. 
public class ValidationError {
    private String message;
   
    protected ValidationError(String message) {
        this.message = message;
    }

    public static ValidationError InvalidDiceCountLength = 
        new ValidationError("Please specify at least two dice.");

    public static ValidationError InvalidFaceCount = 
        new ValidationError("The dice must have 6 faces.");    
        
    public override String ToString() {
        return String.Join("\n", 
            "Argument error.",
            message, 
            "Example: 1,2,3,4,5,6 1,2,3,4,5,6.");
    }    
}

It's not an ideal approach (e.g., usage of the ToString method to generate UI messages is frowned upon), but you may access existing errors by using "predefined" instances like ValidationError.InvalidFaceCount and new errors can be added without code modification. Of course, you may tune it for your needs, e.g., the code above doesn't allow direct instantiation—constructor is protected—but allows subclassing to create new error types without changing error class or some enum for that. So, there are a lot of nuances, but it's definitely better than the class that accepts enum in constructor.

There are additional big problems with using exceptions for the expected data entry errors (in short, don't do that)—that's why class "ValidationError" is not an exception.

6-9 classes is not the ideal number of classes for this task, it's the lower bound. Because it's too complex to be in a single class, it's too much "job". 
Every class should have only one responsibility—it's a major design principle. In fact, it's one of the SOLID principles—I will write about them later. 
For example, if we decide to change how help works, e.g., to print list of "winning over" dice for each of the available dice instead of the probability  table, we should not even touch the class that contains the logic of HMAC calculation or menu "rendering". From the experience, your classes are never too small. They alsways are too big. Always remember about single responsibility.
